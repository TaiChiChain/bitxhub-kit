// Code generated by MockGen. DO NOT EDIT.
// Source: txpool.go
//
// Generated by this command:
//
//	mockgen -destination mock_txpool/mock_txpool.go -package mock_txpool -source txpool.go -typed
//

// Package mock_txpool is a generated GoMock package.
package mock_txpool

import (
	reflect "reflect"

	txpool "github.com/axiomesh/axiom-kit/txpool"
	types "github.com/axiomesh/axiom-kit/types"
	gomock "go.uber.org/mock/gomock"
)

// MockTxPool is a mock of TxPool interface.
type MockTxPool[T any, Constraint types.TXConstraint[T]] struct {
	ctrl     *gomock.Controller
	recorder *MockTxPoolMockRecorder[T, Constraint]
}

// MockTxPoolMockRecorder is the mock recorder for MockTxPool.
type MockTxPoolMockRecorder[T any, Constraint types.TXConstraint[T]] struct {
	mock *MockTxPool[T, Constraint]
}

// NewMockTxPool creates a new mock instance.
func NewMockTxPool[T any, Constraint types.TXConstraint[T]](ctrl *gomock.Controller) *MockTxPool[T, Constraint] {
	mock := &MockTxPool[T, Constraint]{ctrl: ctrl}
	mock.recorder = &MockTxPoolMockRecorder[T, Constraint]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTxPool[T, Constraint]) EXPECT() *MockTxPoolMockRecorder[T, Constraint] {
	return m.recorder
}

// AddLocalTx mocks base method.
func (m *MockTxPool[T, Constraint]) AddLocalTx(tx *T) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddLocalTx", tx)
	ret0, _ := ret[0].(error)
	return ret0
}

// AddLocalTx indicates an expected call of AddLocalTx.
func (mr *MockTxPoolMockRecorder[T, Constraint]) AddLocalTx(tx any) *MockTxPoolAddLocalTxCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddLocalTx", reflect.TypeOf((*MockTxPool[T, Constraint])(nil).AddLocalTx), tx)
	return &MockTxPoolAddLocalTxCall[T, Constraint]{Call: call}
}

// MockTxPoolAddLocalTxCall wrap *gomock.Call
type MockTxPoolAddLocalTxCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTxPoolAddLocalTxCall[T, Constraint]) Return(arg0 error) *MockTxPoolAddLocalTxCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTxPoolAddLocalTxCall[T, Constraint]) Do(f func(*T) error) *MockTxPoolAddLocalTxCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTxPoolAddLocalTxCall[T, Constraint]) DoAndReturn(f func(*T) error) *MockTxPoolAddLocalTxCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// AddRebroadcastTxs mocks base method.
func (m *MockTxPool[T, Constraint]) AddRebroadcastTxs(txs []*T) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "AddRebroadcastTxs", txs)
}

// AddRebroadcastTxs indicates an expected call of AddRebroadcastTxs.
func (mr *MockTxPoolMockRecorder[T, Constraint]) AddRebroadcastTxs(txs any) *MockTxPoolAddRebroadcastTxsCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddRebroadcastTxs", reflect.TypeOf((*MockTxPool[T, Constraint])(nil).AddRebroadcastTxs), txs)
	return &MockTxPoolAddRebroadcastTxsCall[T, Constraint]{Call: call}
}

// MockTxPoolAddRebroadcastTxsCall wrap *gomock.Call
type MockTxPoolAddRebroadcastTxsCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTxPoolAddRebroadcastTxsCall[T, Constraint]) Return() *MockTxPoolAddRebroadcastTxsCall[T, Constraint] {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTxPoolAddRebroadcastTxsCall[T, Constraint]) Do(f func([]*T)) *MockTxPoolAddRebroadcastTxsCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTxPoolAddRebroadcastTxsCall[T, Constraint]) DoAndReturn(f func([]*T)) *MockTxPoolAddRebroadcastTxsCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// AddRemoteTxs mocks base method.
func (m *MockTxPool[T, Constraint]) AddRemoteTxs(txs []*T) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "AddRemoteTxs", txs)
}

// AddRemoteTxs indicates an expected call of AddRemoteTxs.
func (mr *MockTxPoolMockRecorder[T, Constraint]) AddRemoteTxs(txs any) *MockTxPoolAddRemoteTxsCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddRemoteTxs", reflect.TypeOf((*MockTxPool[T, Constraint])(nil).AddRemoteTxs), txs)
	return &MockTxPoolAddRemoteTxsCall[T, Constraint]{Call: call}
}

// MockTxPoolAddRemoteTxsCall wrap *gomock.Call
type MockTxPoolAddRemoteTxsCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTxPoolAddRemoteTxsCall[T, Constraint]) Return() *MockTxPoolAddRemoteTxsCall[T, Constraint] {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTxPoolAddRemoteTxsCall[T, Constraint]) Do(f func([]*T)) *MockTxPoolAddRemoteTxsCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTxPoolAddRemoteTxsCall[T, Constraint]) DoAndReturn(f func([]*T)) *MockTxPoolAddRemoteTxsCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FilterOutOfDateRequests mocks base method.
func (m *MockTxPool[T, Constraint]) FilterOutOfDateRequests(timeout bool) []*T {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FilterOutOfDateRequests", timeout)
	ret0, _ := ret[0].([]*T)
	return ret0
}

// FilterOutOfDateRequests indicates an expected call of FilterOutOfDateRequests.
func (mr *MockTxPoolMockRecorder[T, Constraint]) FilterOutOfDateRequests(timeout any) *MockTxPoolFilterOutOfDateRequestsCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FilterOutOfDateRequests", reflect.TypeOf((*MockTxPool[T, Constraint])(nil).FilterOutOfDateRequests), timeout)
	return &MockTxPoolFilterOutOfDateRequestsCall[T, Constraint]{Call: call}
}

// MockTxPoolFilterOutOfDateRequestsCall wrap *gomock.Call
type MockTxPoolFilterOutOfDateRequestsCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTxPoolFilterOutOfDateRequestsCall[T, Constraint]) Return(arg0 []*T) *MockTxPoolFilterOutOfDateRequestsCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTxPoolFilterOutOfDateRequestsCall[T, Constraint]) Do(f func(bool) []*T) *MockTxPoolFilterOutOfDateRequestsCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTxPoolFilterOutOfDateRequestsCall[T, Constraint]) DoAndReturn(f func(bool) []*T) *MockTxPoolFilterOutOfDateRequestsCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GenerateRequestBatch mocks base method.
func (m *MockTxPool[T, Constraint]) GenerateRequestBatch(typ int) (*txpool.RequestHashBatch[T, Constraint], error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GenerateRequestBatch", typ)
	ret0, _ := ret[0].(*txpool.RequestHashBatch[T, Constraint])
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GenerateRequestBatch indicates an expected call of GenerateRequestBatch.
func (mr *MockTxPoolMockRecorder[T, Constraint]) GenerateRequestBatch(typ any) *MockTxPoolGenerateRequestBatchCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GenerateRequestBatch", reflect.TypeOf((*MockTxPool[T, Constraint])(nil).GenerateRequestBatch), typ)
	return &MockTxPoolGenerateRequestBatchCall[T, Constraint]{Call: call}
}

// MockTxPoolGenerateRequestBatchCall wrap *gomock.Call
type MockTxPoolGenerateRequestBatchCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTxPoolGenerateRequestBatchCall[T, Constraint]) Return(arg0 *txpool.RequestHashBatch[T, Constraint], arg1 error) *MockTxPoolGenerateRequestBatchCall[T, Constraint] {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTxPoolGenerateRequestBatchCall[T, Constraint]) Do(f func(int) (*txpool.RequestHashBatch[T, Constraint], error)) *MockTxPoolGenerateRequestBatchCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTxPoolGenerateRequestBatchCall[T, Constraint]) DoAndReturn(f func(int) (*txpool.RequestHashBatch[T, Constraint], error)) *MockTxPoolGenerateRequestBatchCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetAccountMeta mocks base method.
func (m *MockTxPool[T, Constraint]) GetAccountMeta(account string, full bool) *txpool.AccountMeta[T, Constraint] {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetAccountMeta", account, full)
	ret0, _ := ret[0].(*txpool.AccountMeta[T, Constraint])
	return ret0
}

// GetAccountMeta indicates an expected call of GetAccountMeta.
func (mr *MockTxPoolMockRecorder[T, Constraint]) GetAccountMeta(account, full any) *MockTxPoolGetAccountMetaCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAccountMeta", reflect.TypeOf((*MockTxPool[T, Constraint])(nil).GetAccountMeta), account, full)
	return &MockTxPoolGetAccountMetaCall[T, Constraint]{Call: call}
}

// MockTxPoolGetAccountMetaCall wrap *gomock.Call
type MockTxPoolGetAccountMetaCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTxPoolGetAccountMetaCall[T, Constraint]) Return(arg0 *txpool.AccountMeta[T, Constraint]) *MockTxPoolGetAccountMetaCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTxPoolGetAccountMetaCall[T, Constraint]) Do(f func(string, bool) *txpool.AccountMeta[T, Constraint]) *MockTxPoolGetAccountMetaCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTxPoolGetAccountMetaCall[T, Constraint]) DoAndReturn(f func(string, bool) *txpool.AccountMeta[T, Constraint]) *MockTxPoolGetAccountMetaCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetChainInfo mocks base method.
func (m *MockTxPool[T, Constraint]) GetChainInfo() *txpool.ChainInfo {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetChainInfo")
	ret0, _ := ret[0].(*txpool.ChainInfo)
	return ret0
}

// GetChainInfo indicates an expected call of GetChainInfo.
func (mr *MockTxPoolMockRecorder[T, Constraint]) GetChainInfo() *MockTxPoolGetChainInfoCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetChainInfo", reflect.TypeOf((*MockTxPool[T, Constraint])(nil).GetChainInfo))
	return &MockTxPoolGetChainInfoCall[T, Constraint]{Call: call}
}

// MockTxPoolGetChainInfoCall wrap *gomock.Call
type MockTxPoolGetChainInfoCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTxPoolGetChainInfoCall[T, Constraint]) Return(arg0 *txpool.ChainInfo) *MockTxPoolGetChainInfoCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTxPoolGetChainInfoCall[T, Constraint]) Do(f func() *txpool.ChainInfo) *MockTxPoolGetChainInfoCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTxPoolGetChainInfoCall[T, Constraint]) DoAndReturn(f func() *txpool.ChainInfo) *MockTxPoolGetChainInfoCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetLocalTxs mocks base method.
func (m *MockTxPool[T, Constraint]) GetLocalTxs() [][]byte {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetLocalTxs")
	ret0, _ := ret[0].([][]byte)
	return ret0
}

// GetLocalTxs indicates an expected call of GetLocalTxs.
func (mr *MockTxPoolMockRecorder[T, Constraint]) GetLocalTxs() *MockTxPoolGetLocalTxsCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetLocalTxs", reflect.TypeOf((*MockTxPool[T, Constraint])(nil).GetLocalTxs))
	return &MockTxPoolGetLocalTxsCall[T, Constraint]{Call: call}
}

// MockTxPoolGetLocalTxsCall wrap *gomock.Call
type MockTxPoolGetLocalTxsCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTxPoolGetLocalTxsCall[T, Constraint]) Return(arg0 [][]byte) *MockTxPoolGetLocalTxsCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTxPoolGetLocalTxsCall[T, Constraint]) Do(f func() [][]byte) *MockTxPoolGetLocalTxsCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTxPoolGetLocalTxsCall[T, Constraint]) DoAndReturn(f func() [][]byte) *MockTxPoolGetLocalTxsCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetMeta mocks base method.
func (m *MockTxPool[T, Constraint]) GetMeta(full bool) *txpool.Meta[T, Constraint] {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetMeta", full)
	ret0, _ := ret[0].(*txpool.Meta[T, Constraint])
	return ret0
}

// GetMeta indicates an expected call of GetMeta.
func (mr *MockTxPoolMockRecorder[T, Constraint]) GetMeta(full any) *MockTxPoolGetMetaCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMeta", reflect.TypeOf((*MockTxPool[T, Constraint])(nil).GetMeta), full)
	return &MockTxPoolGetMetaCall[T, Constraint]{Call: call}
}

// MockTxPoolGetMetaCall wrap *gomock.Call
type MockTxPoolGetMetaCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTxPoolGetMetaCall[T, Constraint]) Return(arg0 *txpool.Meta[T, Constraint]) *MockTxPoolGetMetaCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTxPoolGetMetaCall[T, Constraint]) Do(f func(bool) *txpool.Meta[T, Constraint]) *MockTxPoolGetMetaCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTxPoolGetMetaCall[T, Constraint]) DoAndReturn(f func(bool) *txpool.Meta[T, Constraint]) *MockTxPoolGetMetaCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetPendingTxByHash mocks base method.
func (m *MockTxPool[T, Constraint]) GetPendingTxByHash(txHash string) *T {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetPendingTxByHash", txHash)
	ret0, _ := ret[0].(*T)
	return ret0
}

// GetPendingTxByHash indicates an expected call of GetPendingTxByHash.
func (mr *MockTxPoolMockRecorder[T, Constraint]) GetPendingTxByHash(txHash any) *MockTxPoolGetPendingTxByHashCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPendingTxByHash", reflect.TypeOf((*MockTxPool[T, Constraint])(nil).GetPendingTxByHash), txHash)
	return &MockTxPoolGetPendingTxByHashCall[T, Constraint]{Call: call}
}

// MockTxPoolGetPendingTxByHashCall wrap *gomock.Call
type MockTxPoolGetPendingTxByHashCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTxPoolGetPendingTxByHashCall[T, Constraint]) Return(arg0 *T) *MockTxPoolGetPendingTxByHashCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTxPoolGetPendingTxByHashCall[T, Constraint]) Do(f func(string) *T) *MockTxPoolGetPendingTxByHashCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTxPoolGetPendingTxByHashCall[T, Constraint]) DoAndReturn(f func(string) *T) *MockTxPoolGetPendingTxByHashCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetPendingTxCountByAccount mocks base method.
func (m *MockTxPool[T, Constraint]) GetPendingTxCountByAccount(account string) uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetPendingTxCountByAccount", account)
	ret0, _ := ret[0].(uint64)
	return ret0
}

// GetPendingTxCountByAccount indicates an expected call of GetPendingTxCountByAccount.
func (mr *MockTxPoolMockRecorder[T, Constraint]) GetPendingTxCountByAccount(account any) *MockTxPoolGetPendingTxCountByAccountCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPendingTxCountByAccount", reflect.TypeOf((*MockTxPool[T, Constraint])(nil).GetPendingTxCountByAccount), account)
	return &MockTxPoolGetPendingTxCountByAccountCall[T, Constraint]{Call: call}
}

// MockTxPoolGetPendingTxCountByAccountCall wrap *gomock.Call
type MockTxPoolGetPendingTxCountByAccountCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTxPoolGetPendingTxCountByAccountCall[T, Constraint]) Return(arg0 uint64) *MockTxPoolGetPendingTxCountByAccountCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTxPoolGetPendingTxCountByAccountCall[T, Constraint]) Do(f func(string) uint64) *MockTxPoolGetPendingTxCountByAccountCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTxPoolGetPendingTxCountByAccountCall[T, Constraint]) DoAndReturn(f func(string) uint64) *MockTxPoolGetPendingTxCountByAccountCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetRequestsByHashList mocks base method.
func (m *MockTxPool[T, Constraint]) GetRequestsByHashList(batchHash string, timestamp int64, hashList, deDuplicateTxHashes []string) ([]*T, []bool, map[uint64]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetRequestsByHashList", batchHash, timestamp, hashList, deDuplicateTxHashes)
	ret0, _ := ret[0].([]*T)
	ret1, _ := ret[1].([]bool)
	ret2, _ := ret[2].(map[uint64]string)
	ret3, _ := ret[3].(error)
	return ret0, ret1, ret2, ret3
}

// GetRequestsByHashList indicates an expected call of GetRequestsByHashList.
func (mr *MockTxPoolMockRecorder[T, Constraint]) GetRequestsByHashList(batchHash, timestamp, hashList, deDuplicateTxHashes any) *MockTxPoolGetRequestsByHashListCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetRequestsByHashList", reflect.TypeOf((*MockTxPool[T, Constraint])(nil).GetRequestsByHashList), batchHash, timestamp, hashList, deDuplicateTxHashes)
	return &MockTxPoolGetRequestsByHashListCall[T, Constraint]{Call: call}
}

// MockTxPoolGetRequestsByHashListCall wrap *gomock.Call
type MockTxPoolGetRequestsByHashListCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTxPoolGetRequestsByHashListCall[T, Constraint]) Return(txs []*T, list []bool, missingTxsHash map[uint64]string, err error) *MockTxPoolGetRequestsByHashListCall[T, Constraint] {
	c.Call = c.Call.Return(txs, list, missingTxsHash, err)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTxPoolGetRequestsByHashListCall[T, Constraint]) Do(f func(string, int64, []string, []string) ([]*T, []bool, map[uint64]string, error)) *MockTxPoolGetRequestsByHashListCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTxPoolGetRequestsByHashListCall[T, Constraint]) DoAndReturn(f func(string, int64, []string, []string) ([]*T, []bool, map[uint64]string, error)) *MockTxPoolGetRequestsByHashListCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetTotalPendingTxCount mocks base method.
func (m *MockTxPool[T, Constraint]) GetTotalPendingTxCount() uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetTotalPendingTxCount")
	ret0, _ := ret[0].(uint64)
	return ret0
}

// GetTotalPendingTxCount indicates an expected call of GetTotalPendingTxCount.
func (mr *MockTxPoolMockRecorder[T, Constraint]) GetTotalPendingTxCount() *MockTxPoolGetTotalPendingTxCountCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTotalPendingTxCount", reflect.TypeOf((*MockTxPool[T, Constraint])(nil).GetTotalPendingTxCount))
	return &MockTxPoolGetTotalPendingTxCountCall[T, Constraint]{Call: call}
}

// MockTxPoolGetTotalPendingTxCountCall wrap *gomock.Call
type MockTxPoolGetTotalPendingTxCountCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTxPoolGetTotalPendingTxCountCall[T, Constraint]) Return(arg0 uint64) *MockTxPoolGetTotalPendingTxCountCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTxPoolGetTotalPendingTxCountCall[T, Constraint]) Do(f func() uint64) *MockTxPoolGetTotalPendingTxCountCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTxPoolGetTotalPendingTxCountCall[T, Constraint]) DoAndReturn(f func() uint64) *MockTxPoolGetTotalPendingTxCountCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// HasPendingRequestInPool mocks base method.
func (m *MockTxPool[T, Constraint]) HasPendingRequestInPool() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HasPendingRequestInPool")
	ret0, _ := ret[0].(bool)
	return ret0
}

// HasPendingRequestInPool indicates an expected call of HasPendingRequestInPool.
func (mr *MockTxPoolMockRecorder[T, Constraint]) HasPendingRequestInPool() *MockTxPoolHasPendingRequestInPoolCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HasPendingRequestInPool", reflect.TypeOf((*MockTxPool[T, Constraint])(nil).HasPendingRequestInPool))
	return &MockTxPoolHasPendingRequestInPoolCall[T, Constraint]{Call: call}
}

// MockTxPoolHasPendingRequestInPoolCall wrap *gomock.Call
type MockTxPoolHasPendingRequestInPoolCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTxPoolHasPendingRequestInPoolCall[T, Constraint]) Return(arg0 bool) *MockTxPoolHasPendingRequestInPoolCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTxPoolHasPendingRequestInPoolCall[T, Constraint]) Do(f func() bool) *MockTxPoolHasPendingRequestInPoolCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTxPoolHasPendingRequestInPoolCall[T, Constraint]) DoAndReturn(f func() bool) *MockTxPoolHasPendingRequestInPoolCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Init mocks base method.
func (m *MockTxPool[T, Constraint]) Init(config txpool.ConsensusConfig) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Init", config)
}

// Init indicates an expected call of Init.
func (mr *MockTxPoolMockRecorder[T, Constraint]) Init(config any) *MockTxPoolInitCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Init", reflect.TypeOf((*MockTxPool[T, Constraint])(nil).Init), config)
	return &MockTxPoolInitCall[T, Constraint]{Call: call}
}

// MockTxPoolInitCall wrap *gomock.Call
type MockTxPoolInitCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTxPoolInitCall[T, Constraint]) Return() *MockTxPoolInitCall[T, Constraint] {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTxPoolInitCall[T, Constraint]) Do(f func(txpool.ConsensusConfig)) *MockTxPoolInitCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTxPoolInitCall[T, Constraint]) DoAndReturn(f func(txpool.ConsensusConfig)) *MockTxPoolInitCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// IsPoolFull mocks base method.
func (m *MockTxPool[T, Constraint]) IsPoolFull() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsPoolFull")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsPoolFull indicates an expected call of IsPoolFull.
func (mr *MockTxPoolMockRecorder[T, Constraint]) IsPoolFull() *MockTxPoolIsPoolFullCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsPoolFull", reflect.TypeOf((*MockTxPool[T, Constraint])(nil).IsPoolFull))
	return &MockTxPoolIsPoolFullCall[T, Constraint]{Call: call}
}

// MockTxPoolIsPoolFullCall wrap *gomock.Call
type MockTxPoolIsPoolFullCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTxPoolIsPoolFullCall[T, Constraint]) Return(arg0 bool) *MockTxPoolIsPoolFullCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTxPoolIsPoolFullCall[T, Constraint]) Do(f func() bool) *MockTxPoolIsPoolFullCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTxPoolIsPoolFullCall[T, Constraint]) DoAndReturn(f func() bool) *MockTxPoolIsPoolFullCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// IsStarted mocks base method.
func (m *MockTxPool[T, Constraint]) IsStarted() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsStarted")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsStarted indicates an expected call of IsStarted.
func (mr *MockTxPoolMockRecorder[T, Constraint]) IsStarted() *MockTxPoolIsStartedCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsStarted", reflect.TypeOf((*MockTxPool[T, Constraint])(nil).IsStarted))
	return &MockTxPoolIsStartedCall[T, Constraint]{Call: call}
}

// MockTxPoolIsStartedCall wrap *gomock.Call
type MockTxPoolIsStartedCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTxPoolIsStartedCall[T, Constraint]) Return(arg0 bool) *MockTxPoolIsStartedCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTxPoolIsStartedCall[T, Constraint]) Do(f func() bool) *MockTxPoolIsStartedCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTxPoolIsStartedCall[T, Constraint]) DoAndReturn(f func() bool) *MockTxPoolIsStartedCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// PendingRequestsNumberIsReady mocks base method.
func (m *MockTxPool[T, Constraint]) PendingRequestsNumberIsReady() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PendingRequestsNumberIsReady")
	ret0, _ := ret[0].(bool)
	return ret0
}

// PendingRequestsNumberIsReady indicates an expected call of PendingRequestsNumberIsReady.
func (mr *MockTxPoolMockRecorder[T, Constraint]) PendingRequestsNumberIsReady() *MockTxPoolPendingRequestsNumberIsReadyCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PendingRequestsNumberIsReady", reflect.TypeOf((*MockTxPool[T, Constraint])(nil).PendingRequestsNumberIsReady))
	return &MockTxPoolPendingRequestsNumberIsReadyCall[T, Constraint]{Call: call}
}

// MockTxPoolPendingRequestsNumberIsReadyCall wrap *gomock.Call
type MockTxPoolPendingRequestsNumberIsReadyCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTxPoolPendingRequestsNumberIsReadyCall[T, Constraint]) Return(arg0 bool) *MockTxPoolPendingRequestsNumberIsReadyCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTxPoolPendingRequestsNumberIsReadyCall[T, Constraint]) Do(f func() bool) *MockTxPoolPendingRequestsNumberIsReadyCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTxPoolPendingRequestsNumberIsReadyCall[T, Constraint]) DoAndReturn(f func() bool) *MockTxPoolPendingRequestsNumberIsReadyCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ReConstructBatchByOrder mocks base method.
func (m *MockTxPool[T, Constraint]) ReConstructBatchByOrder(oldBatch *txpool.RequestHashBatch[T, Constraint]) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReConstructBatchByOrder", oldBatch)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReConstructBatchByOrder indicates an expected call of ReConstructBatchByOrder.
func (mr *MockTxPoolMockRecorder[T, Constraint]) ReConstructBatchByOrder(oldBatch any) *MockTxPoolReConstructBatchByOrderCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReConstructBatchByOrder", reflect.TypeOf((*MockTxPool[T, Constraint])(nil).ReConstructBatchByOrder), oldBatch)
	return &MockTxPoolReConstructBatchByOrderCall[T, Constraint]{Call: call}
}

// MockTxPoolReConstructBatchByOrderCall wrap *gomock.Call
type MockTxPoolReConstructBatchByOrderCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTxPoolReConstructBatchByOrderCall[T, Constraint]) Return(deDuplicateTxHashes []string, err error) *MockTxPoolReConstructBatchByOrderCall[T, Constraint] {
	c.Call = c.Call.Return(deDuplicateTxHashes, err)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTxPoolReConstructBatchByOrderCall[T, Constraint]) Do(f func(*txpool.RequestHashBatch[T, Constraint]) ([]string, error)) *MockTxPoolReConstructBatchByOrderCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTxPoolReConstructBatchByOrderCall[T, Constraint]) DoAndReturn(f func(*txpool.RequestHashBatch[T, Constraint]) ([]string, error)) *MockTxPoolReConstructBatchByOrderCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ReceiveMissingRequests mocks base method.
func (m *MockTxPool[T, Constraint]) ReceiveMissingRequests(batchHash string, txs map[uint64]*T) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReceiveMissingRequests", batchHash, txs)
	ret0, _ := ret[0].(error)
	return ret0
}

// ReceiveMissingRequests indicates an expected call of ReceiveMissingRequests.
func (mr *MockTxPoolMockRecorder[T, Constraint]) ReceiveMissingRequests(batchHash, txs any) *MockTxPoolReceiveMissingRequestsCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReceiveMissingRequests", reflect.TypeOf((*MockTxPool[T, Constraint])(nil).ReceiveMissingRequests), batchHash, txs)
	return &MockTxPoolReceiveMissingRequestsCall[T, Constraint]{Call: call}
}

// MockTxPoolReceiveMissingRequestsCall wrap *gomock.Call
type MockTxPoolReceiveMissingRequestsCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTxPoolReceiveMissingRequestsCall[T, Constraint]) Return(arg0 error) *MockTxPoolReceiveMissingRequestsCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTxPoolReceiveMissingRequestsCall[T, Constraint]) Do(f func(string, map[uint64]*T) error) *MockTxPoolReceiveMissingRequestsCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTxPoolReceiveMissingRequestsCall[T, Constraint]) DoAndReturn(f func(string, map[uint64]*T) error) *MockTxPoolReceiveMissingRequestsCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RemoveBatches mocks base method.
func (m *MockTxPool[T, Constraint]) RemoveBatches(batchHashList []string) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "RemoveBatches", batchHashList)
}

// RemoveBatches indicates an expected call of RemoveBatches.
func (mr *MockTxPoolMockRecorder[T, Constraint]) RemoveBatches(batchHashList any) *MockTxPoolRemoveBatchesCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveBatches", reflect.TypeOf((*MockTxPool[T, Constraint])(nil).RemoveBatches), batchHashList)
	return &MockTxPoolRemoveBatchesCall[T, Constraint]{Call: call}
}

// MockTxPoolRemoveBatchesCall wrap *gomock.Call
type MockTxPoolRemoveBatchesCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTxPoolRemoveBatchesCall[T, Constraint]) Return() *MockTxPoolRemoveBatchesCall[T, Constraint] {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTxPoolRemoveBatchesCall[T, Constraint]) Do(f func([]string)) *MockTxPoolRemoveBatchesCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTxPoolRemoveBatchesCall[T, Constraint]) DoAndReturn(f func([]string)) *MockTxPoolRemoveBatchesCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RemoveStateUpdatingTxs mocks base method.
func (m *MockTxPool[T, Constraint]) RemoveStateUpdatingTxs(txPointerList []*txpool.WrapperTxPointer) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "RemoveStateUpdatingTxs", txPointerList)
}

// RemoveStateUpdatingTxs indicates an expected call of RemoveStateUpdatingTxs.
func (mr *MockTxPoolMockRecorder[T, Constraint]) RemoveStateUpdatingTxs(txPointerList any) *MockTxPoolRemoveStateUpdatingTxsCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveStateUpdatingTxs", reflect.TypeOf((*MockTxPool[T, Constraint])(nil).RemoveStateUpdatingTxs), txPointerList)
	return &MockTxPoolRemoveStateUpdatingTxsCall[T, Constraint]{Call: call}
}

// MockTxPoolRemoveStateUpdatingTxsCall wrap *gomock.Call
type MockTxPoolRemoveStateUpdatingTxsCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTxPoolRemoveStateUpdatingTxsCall[T, Constraint]) Return() *MockTxPoolRemoveStateUpdatingTxsCall[T, Constraint] {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTxPoolRemoveStateUpdatingTxsCall[T, Constraint]) Do(f func([]*txpool.WrapperTxPointer)) *MockTxPoolRemoveStateUpdatingTxsCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTxPoolRemoveStateUpdatingTxsCall[T, Constraint]) DoAndReturn(f func([]*txpool.WrapperTxPointer)) *MockTxPoolRemoveStateUpdatingTxsCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ReplyBatchSignal mocks base method.
func (m *MockTxPool[T, Constraint]) ReplyBatchSignal() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "ReplyBatchSignal")
}

// ReplyBatchSignal indicates an expected call of ReplyBatchSignal.
func (mr *MockTxPoolMockRecorder[T, Constraint]) ReplyBatchSignal() *MockTxPoolReplyBatchSignalCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReplyBatchSignal", reflect.TypeOf((*MockTxPool[T, Constraint])(nil).ReplyBatchSignal))
	return &MockTxPoolReplyBatchSignalCall[T, Constraint]{Call: call}
}

// MockTxPoolReplyBatchSignalCall wrap *gomock.Call
type MockTxPoolReplyBatchSignalCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTxPoolReplyBatchSignalCall[T, Constraint]) Return() *MockTxPoolReplyBatchSignalCall[T, Constraint] {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTxPoolReplyBatchSignalCall[T, Constraint]) Do(f func()) *MockTxPoolReplyBatchSignalCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTxPoolReplyBatchSignalCall[T, Constraint]) DoAndReturn(f func()) *MockTxPoolReplyBatchSignalCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RestoreOneBatch mocks base method.
func (m *MockTxPool[T, Constraint]) RestoreOneBatch(hash string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RestoreOneBatch", hash)
	ret0, _ := ret[0].(error)
	return ret0
}

// RestoreOneBatch indicates an expected call of RestoreOneBatch.
func (mr *MockTxPoolMockRecorder[T, Constraint]) RestoreOneBatch(hash any) *MockTxPoolRestoreOneBatchCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RestoreOneBatch", reflect.TypeOf((*MockTxPool[T, Constraint])(nil).RestoreOneBatch), hash)
	return &MockTxPoolRestoreOneBatchCall[T, Constraint]{Call: call}
}

// MockTxPoolRestoreOneBatchCall wrap *gomock.Call
type MockTxPoolRestoreOneBatchCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTxPoolRestoreOneBatchCall[T, Constraint]) Return(arg0 error) *MockTxPoolRestoreOneBatchCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTxPoolRestoreOneBatchCall[T, Constraint]) Do(f func(string) error) *MockTxPoolRestoreOneBatchCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTxPoolRestoreOneBatchCall[T, Constraint]) DoAndReturn(f func(string) error) *MockTxPoolRestoreOneBatchCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RestorePool mocks base method.
func (m *MockTxPool[T, Constraint]) RestorePool() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "RestorePool")
}

// RestorePool indicates an expected call of RestorePool.
func (mr *MockTxPoolMockRecorder[T, Constraint]) RestorePool() *MockTxPoolRestorePoolCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RestorePool", reflect.TypeOf((*MockTxPool[T, Constraint])(nil).RestorePool))
	return &MockTxPoolRestorePoolCall[T, Constraint]{Call: call}
}

// MockTxPoolRestorePoolCall wrap *gomock.Call
type MockTxPoolRestorePoolCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTxPoolRestorePoolCall[T, Constraint]) Return() *MockTxPoolRestorePoolCall[T, Constraint] {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTxPoolRestorePoolCall[T, Constraint]) Do(f func()) *MockTxPoolRestorePoolCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTxPoolRestorePoolCall[T, Constraint]) DoAndReturn(f func()) *MockTxPoolRestorePoolCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SendMissingRequests mocks base method.
func (m *MockTxPool[T, Constraint]) SendMissingRequests(batchHash string, missingHashList map[uint64]string) (map[uint64]*T, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SendMissingRequests", batchHash, missingHashList)
	ret0, _ := ret[0].(map[uint64]*T)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SendMissingRequests indicates an expected call of SendMissingRequests.
func (mr *MockTxPoolMockRecorder[T, Constraint]) SendMissingRequests(batchHash, missingHashList any) *MockTxPoolSendMissingRequestsCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SendMissingRequests", reflect.TypeOf((*MockTxPool[T, Constraint])(nil).SendMissingRequests), batchHash, missingHashList)
	return &MockTxPoolSendMissingRequestsCall[T, Constraint]{Call: call}
}

// MockTxPoolSendMissingRequestsCall wrap *gomock.Call
type MockTxPoolSendMissingRequestsCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTxPoolSendMissingRequestsCall[T, Constraint]) Return(txs map[uint64]*T, err error) *MockTxPoolSendMissingRequestsCall[T, Constraint] {
	c.Call = c.Call.Return(txs, err)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTxPoolSendMissingRequestsCall[T, Constraint]) Do(f func(string, map[uint64]string) (map[uint64]*T, error)) *MockTxPoolSendMissingRequestsCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTxPoolSendMissingRequestsCall[T, Constraint]) DoAndReturn(f func(string, map[uint64]string) (map[uint64]*T, error)) *MockTxPoolSendMissingRequestsCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Start mocks base method.
func (m *MockTxPool[T, Constraint]) Start() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Start")
	ret0, _ := ret[0].(error)
	return ret0
}

// Start indicates an expected call of Start.
func (mr *MockTxPoolMockRecorder[T, Constraint]) Start() *MockTxPoolStartCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Start", reflect.TypeOf((*MockTxPool[T, Constraint])(nil).Start))
	return &MockTxPoolStartCall[T, Constraint]{Call: call}
}

// MockTxPoolStartCall wrap *gomock.Call
type MockTxPoolStartCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTxPoolStartCall[T, Constraint]) Return(arg0 error) *MockTxPoolStartCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTxPoolStartCall[T, Constraint]) Do(f func() error) *MockTxPoolStartCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTxPoolStartCall[T, Constraint]) DoAndReturn(f func() error) *MockTxPoolStartCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Stop mocks base method.
func (m *MockTxPool[T, Constraint]) Stop() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Stop")
}

// Stop indicates an expected call of Stop.
func (mr *MockTxPoolMockRecorder[T, Constraint]) Stop() *MockTxPoolStopCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Stop", reflect.TypeOf((*MockTxPool[T, Constraint])(nil).Stop))
	return &MockTxPoolStopCall[T, Constraint]{Call: call}
}

// MockTxPoolStopCall wrap *gomock.Call
type MockTxPoolStopCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTxPoolStopCall[T, Constraint]) Return() *MockTxPoolStopCall[T, Constraint] {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTxPoolStopCall[T, Constraint]) Do(f func()) *MockTxPoolStopCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTxPoolStopCall[T, Constraint]) DoAndReturn(f func()) *MockTxPoolStopCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UpdateChainInfo mocks base method.
func (m *MockTxPool[T, Constraint]) UpdateChainInfo(info *txpool.ChainInfo) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "UpdateChainInfo", info)
}

// UpdateChainInfo indicates an expected call of UpdateChainInfo.
func (mr *MockTxPoolMockRecorder[T, Constraint]) UpdateChainInfo(info any) *MockTxPoolUpdateChainInfoCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateChainInfo", reflect.TypeOf((*MockTxPool[T, Constraint])(nil).UpdateChainInfo), info)
	return &MockTxPoolUpdateChainInfoCall[T, Constraint]{Call: call}
}

// MockTxPoolUpdateChainInfoCall wrap *gomock.Call
type MockTxPoolUpdateChainInfoCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockTxPoolUpdateChainInfoCall[T, Constraint]) Return() *MockTxPoolUpdateChainInfoCall[T, Constraint] {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockTxPoolUpdateChainInfoCall[T, Constraint]) Do(f func(*txpool.ChainInfo)) *MockTxPoolUpdateChainInfoCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockTxPoolUpdateChainInfoCall[T, Constraint]) DoAndReturn(f func(*txpool.ChainInfo)) *MockTxPoolUpdateChainInfoCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MocktxPoolInfo is a mock of txPoolInfo interface.
type MocktxPoolInfo[T any, Constraint types.TXConstraint[T]] struct {
	ctrl     *gomock.Controller
	recorder *MocktxPoolInfoMockRecorder[T, Constraint]
}

// MocktxPoolInfoMockRecorder is the mock recorder for MocktxPoolInfo.
type MocktxPoolInfoMockRecorder[T any, Constraint types.TXConstraint[T]] struct {
	mock *MocktxPoolInfo[T, Constraint]
}

// NewMocktxPoolInfo creates a new mock instance.
func NewMocktxPoolInfo[T any, Constraint types.TXConstraint[T]](ctrl *gomock.Controller) *MocktxPoolInfo[T, Constraint] {
	mock := &MocktxPoolInfo[T, Constraint]{ctrl: ctrl}
	mock.recorder = &MocktxPoolInfoMockRecorder[T, Constraint]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MocktxPoolInfo[T, Constraint]) EXPECT() *MocktxPoolInfoMockRecorder[T, Constraint] {
	return m.recorder
}

// GetAccountMeta mocks base method.
func (m *MocktxPoolInfo[T, Constraint]) GetAccountMeta(account string, full bool) *txpool.AccountMeta[T, Constraint] {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetAccountMeta", account, full)
	ret0, _ := ret[0].(*txpool.AccountMeta[T, Constraint])
	return ret0
}

// GetAccountMeta indicates an expected call of GetAccountMeta.
func (mr *MocktxPoolInfoMockRecorder[T, Constraint]) GetAccountMeta(account, full any) *MocktxPoolInfoGetAccountMetaCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAccountMeta", reflect.TypeOf((*MocktxPoolInfo[T, Constraint])(nil).GetAccountMeta), account, full)
	return &MocktxPoolInfoGetAccountMetaCall[T, Constraint]{Call: call}
}

// MocktxPoolInfoGetAccountMetaCall wrap *gomock.Call
type MocktxPoolInfoGetAccountMetaCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MocktxPoolInfoGetAccountMetaCall[T, Constraint]) Return(arg0 *txpool.AccountMeta[T, Constraint]) *MocktxPoolInfoGetAccountMetaCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MocktxPoolInfoGetAccountMetaCall[T, Constraint]) Do(f func(string, bool) *txpool.AccountMeta[T, Constraint]) *MocktxPoolInfoGetAccountMetaCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MocktxPoolInfoGetAccountMetaCall[T, Constraint]) DoAndReturn(f func(string, bool) *txpool.AccountMeta[T, Constraint]) *MocktxPoolInfoGetAccountMetaCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetChainInfo mocks base method.
func (m *MocktxPoolInfo[T, Constraint]) GetChainInfo() *txpool.ChainInfo {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetChainInfo")
	ret0, _ := ret[0].(*txpool.ChainInfo)
	return ret0
}

// GetChainInfo indicates an expected call of GetChainInfo.
func (mr *MocktxPoolInfoMockRecorder[T, Constraint]) GetChainInfo() *MocktxPoolInfoGetChainInfoCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetChainInfo", reflect.TypeOf((*MocktxPoolInfo[T, Constraint])(nil).GetChainInfo))
	return &MocktxPoolInfoGetChainInfoCall[T, Constraint]{Call: call}
}

// MocktxPoolInfoGetChainInfoCall wrap *gomock.Call
type MocktxPoolInfoGetChainInfoCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MocktxPoolInfoGetChainInfoCall[T, Constraint]) Return(arg0 *txpool.ChainInfo) *MocktxPoolInfoGetChainInfoCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MocktxPoolInfoGetChainInfoCall[T, Constraint]) Do(f func() *txpool.ChainInfo) *MocktxPoolInfoGetChainInfoCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MocktxPoolInfoGetChainInfoCall[T, Constraint]) DoAndReturn(f func() *txpool.ChainInfo) *MocktxPoolInfoGetChainInfoCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetMeta mocks base method.
func (m *MocktxPoolInfo[T, Constraint]) GetMeta(full bool) *txpool.Meta[T, Constraint] {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetMeta", full)
	ret0, _ := ret[0].(*txpool.Meta[T, Constraint])
	return ret0
}

// GetMeta indicates an expected call of GetMeta.
func (mr *MocktxPoolInfoMockRecorder[T, Constraint]) GetMeta(full any) *MocktxPoolInfoGetMetaCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMeta", reflect.TypeOf((*MocktxPoolInfo[T, Constraint])(nil).GetMeta), full)
	return &MocktxPoolInfoGetMetaCall[T, Constraint]{Call: call}
}

// MocktxPoolInfoGetMetaCall wrap *gomock.Call
type MocktxPoolInfoGetMetaCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MocktxPoolInfoGetMetaCall[T, Constraint]) Return(arg0 *txpool.Meta[T, Constraint]) *MocktxPoolInfoGetMetaCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MocktxPoolInfoGetMetaCall[T, Constraint]) Do(f func(bool) *txpool.Meta[T, Constraint]) *MocktxPoolInfoGetMetaCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MocktxPoolInfoGetMetaCall[T, Constraint]) DoAndReturn(f func(bool) *txpool.Meta[T, Constraint]) *MocktxPoolInfoGetMetaCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetPendingTxByHash mocks base method.
func (m *MocktxPoolInfo[T, Constraint]) GetPendingTxByHash(txHash string) *T {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetPendingTxByHash", txHash)
	ret0, _ := ret[0].(*T)
	return ret0
}

// GetPendingTxByHash indicates an expected call of GetPendingTxByHash.
func (mr *MocktxPoolInfoMockRecorder[T, Constraint]) GetPendingTxByHash(txHash any) *MocktxPoolInfoGetPendingTxByHashCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPendingTxByHash", reflect.TypeOf((*MocktxPoolInfo[T, Constraint])(nil).GetPendingTxByHash), txHash)
	return &MocktxPoolInfoGetPendingTxByHashCall[T, Constraint]{Call: call}
}

// MocktxPoolInfoGetPendingTxByHashCall wrap *gomock.Call
type MocktxPoolInfoGetPendingTxByHashCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MocktxPoolInfoGetPendingTxByHashCall[T, Constraint]) Return(arg0 *T) *MocktxPoolInfoGetPendingTxByHashCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MocktxPoolInfoGetPendingTxByHashCall[T, Constraint]) Do(f func(string) *T) *MocktxPoolInfoGetPendingTxByHashCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MocktxPoolInfoGetPendingTxByHashCall[T, Constraint]) DoAndReturn(f func(string) *T) *MocktxPoolInfoGetPendingTxByHashCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetPendingTxCountByAccount mocks base method.
func (m *MocktxPoolInfo[T, Constraint]) GetPendingTxCountByAccount(account string) uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetPendingTxCountByAccount", account)
	ret0, _ := ret[0].(uint64)
	return ret0
}

// GetPendingTxCountByAccount indicates an expected call of GetPendingTxCountByAccount.
func (mr *MocktxPoolInfoMockRecorder[T, Constraint]) GetPendingTxCountByAccount(account any) *MocktxPoolInfoGetPendingTxCountByAccountCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPendingTxCountByAccount", reflect.TypeOf((*MocktxPoolInfo[T, Constraint])(nil).GetPendingTxCountByAccount), account)
	return &MocktxPoolInfoGetPendingTxCountByAccountCall[T, Constraint]{Call: call}
}

// MocktxPoolInfoGetPendingTxCountByAccountCall wrap *gomock.Call
type MocktxPoolInfoGetPendingTxCountByAccountCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MocktxPoolInfoGetPendingTxCountByAccountCall[T, Constraint]) Return(arg0 uint64) *MocktxPoolInfoGetPendingTxCountByAccountCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MocktxPoolInfoGetPendingTxCountByAccountCall[T, Constraint]) Do(f func(string) uint64) *MocktxPoolInfoGetPendingTxCountByAccountCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MocktxPoolInfoGetPendingTxCountByAccountCall[T, Constraint]) DoAndReturn(f func(string) uint64) *MocktxPoolInfoGetPendingTxCountByAccountCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetTotalPendingTxCount mocks base method.
func (m *MocktxPoolInfo[T, Constraint]) GetTotalPendingTxCount() uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetTotalPendingTxCount")
	ret0, _ := ret[0].(uint64)
	return ret0
}

// GetTotalPendingTxCount indicates an expected call of GetTotalPendingTxCount.
func (mr *MocktxPoolInfoMockRecorder[T, Constraint]) GetTotalPendingTxCount() *MocktxPoolInfoGetTotalPendingTxCountCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTotalPendingTxCount", reflect.TypeOf((*MocktxPoolInfo[T, Constraint])(nil).GetTotalPendingTxCount))
	return &MocktxPoolInfoGetTotalPendingTxCountCall[T, Constraint]{Call: call}
}

// MocktxPoolInfoGetTotalPendingTxCountCall wrap *gomock.Call
type MocktxPoolInfoGetTotalPendingTxCountCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MocktxPoolInfoGetTotalPendingTxCountCall[T, Constraint]) Return(arg0 uint64) *MocktxPoolInfoGetTotalPendingTxCountCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MocktxPoolInfoGetTotalPendingTxCountCall[T, Constraint]) Do(f func() uint64) *MocktxPoolInfoGetTotalPendingTxCountCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MocktxPoolInfoGetTotalPendingTxCountCall[T, Constraint]) DoAndReturn(f func() uint64) *MocktxPoolInfoGetTotalPendingTxCountCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// HasPendingRequestInPool mocks base method.
func (m *MocktxPoolInfo[T, Constraint]) HasPendingRequestInPool() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HasPendingRequestInPool")
	ret0, _ := ret[0].(bool)
	return ret0
}

// HasPendingRequestInPool indicates an expected call of HasPendingRequestInPool.
func (mr *MocktxPoolInfoMockRecorder[T, Constraint]) HasPendingRequestInPool() *MocktxPoolInfoHasPendingRequestInPoolCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HasPendingRequestInPool", reflect.TypeOf((*MocktxPoolInfo[T, Constraint])(nil).HasPendingRequestInPool))
	return &MocktxPoolInfoHasPendingRequestInPoolCall[T, Constraint]{Call: call}
}

// MocktxPoolInfoHasPendingRequestInPoolCall wrap *gomock.Call
type MocktxPoolInfoHasPendingRequestInPoolCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MocktxPoolInfoHasPendingRequestInPoolCall[T, Constraint]) Return(arg0 bool) *MocktxPoolInfoHasPendingRequestInPoolCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MocktxPoolInfoHasPendingRequestInPoolCall[T, Constraint]) Do(f func() bool) *MocktxPoolInfoHasPendingRequestInPoolCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MocktxPoolInfoHasPendingRequestInPoolCall[T, Constraint]) DoAndReturn(f func() bool) *MocktxPoolInfoHasPendingRequestInPoolCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// IsPoolFull mocks base method.
func (m *MocktxPoolInfo[T, Constraint]) IsPoolFull() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsPoolFull")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsPoolFull indicates an expected call of IsPoolFull.
func (mr *MocktxPoolInfoMockRecorder[T, Constraint]) IsPoolFull() *MocktxPoolInfoIsPoolFullCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsPoolFull", reflect.TypeOf((*MocktxPoolInfo[T, Constraint])(nil).IsPoolFull))
	return &MocktxPoolInfoIsPoolFullCall[T, Constraint]{Call: call}
}

// MocktxPoolInfoIsPoolFullCall wrap *gomock.Call
type MocktxPoolInfoIsPoolFullCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MocktxPoolInfoIsPoolFullCall[T, Constraint]) Return(arg0 bool) *MocktxPoolInfoIsPoolFullCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MocktxPoolInfoIsPoolFullCall[T, Constraint]) Do(f func() bool) *MocktxPoolInfoIsPoolFullCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MocktxPoolInfoIsPoolFullCall[T, Constraint]) DoAndReturn(f func() bool) *MocktxPoolInfoIsPoolFullCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// IsStarted mocks base method.
func (m *MocktxPoolInfo[T, Constraint]) IsStarted() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsStarted")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsStarted indicates an expected call of IsStarted.
func (mr *MocktxPoolInfoMockRecorder[T, Constraint]) IsStarted() *MocktxPoolInfoIsStartedCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsStarted", reflect.TypeOf((*MocktxPoolInfo[T, Constraint])(nil).IsStarted))
	return &MocktxPoolInfoIsStartedCall[T, Constraint]{Call: call}
}

// MocktxPoolInfoIsStartedCall wrap *gomock.Call
type MocktxPoolInfoIsStartedCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MocktxPoolInfoIsStartedCall[T, Constraint]) Return(arg0 bool) *MocktxPoolInfoIsStartedCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MocktxPoolInfoIsStartedCall[T, Constraint]) Do(f func() bool) *MocktxPoolInfoIsStartedCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MocktxPoolInfoIsStartedCall[T, Constraint]) DoAndReturn(f func() bool) *MocktxPoolInfoIsStartedCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// PendingRequestsNumberIsReady mocks base method.
func (m *MocktxPoolInfo[T, Constraint]) PendingRequestsNumberIsReady() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PendingRequestsNumberIsReady")
	ret0, _ := ret[0].(bool)
	return ret0
}

// PendingRequestsNumberIsReady indicates an expected call of PendingRequestsNumberIsReady.
func (mr *MocktxPoolInfoMockRecorder[T, Constraint]) PendingRequestsNumberIsReady() *MocktxPoolInfoPendingRequestsNumberIsReadyCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PendingRequestsNumberIsReady", reflect.TypeOf((*MocktxPoolInfo[T, Constraint])(nil).PendingRequestsNumberIsReady))
	return &MocktxPoolInfoPendingRequestsNumberIsReadyCall[T, Constraint]{Call: call}
}

// MocktxPoolInfoPendingRequestsNumberIsReadyCall wrap *gomock.Call
type MocktxPoolInfoPendingRequestsNumberIsReadyCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MocktxPoolInfoPendingRequestsNumberIsReadyCall[T, Constraint]) Return(arg0 bool) *MocktxPoolInfoPendingRequestsNumberIsReadyCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MocktxPoolInfoPendingRequestsNumberIsReadyCall[T, Constraint]) Do(f func() bool) *MocktxPoolInfoPendingRequestsNumberIsReadyCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MocktxPoolInfoPendingRequestsNumberIsReadyCall[T, Constraint]) DoAndReturn(f func() bool) *MocktxPoolInfoPendingRequestsNumberIsReadyCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UpdateChainInfo mocks base method.
func (m *MocktxPoolInfo[T, Constraint]) UpdateChainInfo(info *txpool.ChainInfo) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "UpdateChainInfo", info)
}

// UpdateChainInfo indicates an expected call of UpdateChainInfo.
func (mr *MocktxPoolInfoMockRecorder[T, Constraint]) UpdateChainInfo(info any) *MocktxPoolInfoUpdateChainInfoCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateChainInfo", reflect.TypeOf((*MocktxPoolInfo[T, Constraint])(nil).UpdateChainInfo), info)
	return &MocktxPoolInfoUpdateChainInfoCall[T, Constraint]{Call: call}
}

// MocktxPoolInfoUpdateChainInfoCall wrap *gomock.Call
type MocktxPoolInfoUpdateChainInfoCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MocktxPoolInfoUpdateChainInfoCall[T, Constraint]) Return() *MocktxPoolInfoUpdateChainInfoCall[T, Constraint] {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MocktxPoolInfoUpdateChainInfoCall[T, Constraint]) Do(f func(*txpool.ChainInfo)) *MocktxPoolInfoUpdateChainInfoCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MocktxPoolInfoUpdateChainInfoCall[T, Constraint]) DoAndReturn(f func(*txpool.ChainInfo)) *MocktxPoolInfoUpdateChainInfoCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

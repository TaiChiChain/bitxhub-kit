// Code generated by MockGen. DO NOT EDIT.
// Source: txpool.go
//
// Generated by this command:
//
//	mockgen -destination mock_txpool/mock_txpool.go -package mock_txpool -source txpool.go -typed
//

// Package mock_txpool is a generated GoMock package.
package mock_txpool

import (
	reflect "reflect"

	txpool "github.com/axiomesh/axiom-kit/txpool"
	types "github.com/axiomesh/axiom-kit/types"
	gomock "go.uber.org/mock/gomock"
)

// MockTxPool is a mock of TxPool interface.
type MockTxPool[T any, Constraint types.TXConstraint[T]] struct {
	ctrl     *gomock.Controller
	recorder *MockTxPoolMockRecorder[T, Constraint]
}

// MockTxPoolMockRecorder is the mock recorder for MockTxPool.
type MockTxPoolMockRecorder[T any, Constraint types.TXConstraint[T]] struct {
	mock *MockTxPool[T, Constraint]
}

// NewMockTxPool creates a new mock instance.
func NewMockTxPool[T any, Constraint types.TXConstraint[T]](ctrl *gomock.Controller) *MockTxPool[T, Constraint] {
	mock := &MockTxPool[T, Constraint]{ctrl: ctrl}
	mock.recorder = &MockTxPoolMockRecorder[T, Constraint]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTxPool[T, Constraint]) EXPECT() *MockTxPoolMockRecorder[T, Constraint] {
	return m.recorder
}

// AddLocalTx mocks base method.
func (m *MockTxPool[T, Constraint]) AddLocalTx(tx *T) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AddLocalTx", tx)
	ret0, _ := ret[0].(error)
	return ret0
}

// AddLocalTx indicates an expected call of AddLocalTx.
func (mr *MockTxPoolMockRecorder[T, Constraint]) AddLocalTx(tx any) *TxPoolAddLocalTxCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddLocalTx", reflect.TypeOf((*MockTxPool[T, Constraint])(nil).AddLocalTx), tx)
	return &TxPoolAddLocalTxCall[T, Constraint]{Call: call}
}

// TxPoolAddLocalTxCall wrap *gomock.Call
type TxPoolAddLocalTxCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *TxPoolAddLocalTxCall[T, Constraint]) Return(arg0 error) *TxPoolAddLocalTxCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *TxPoolAddLocalTxCall[T, Constraint]) Do(f func(*T) error) *TxPoolAddLocalTxCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *TxPoolAddLocalTxCall[T, Constraint]) DoAndReturn(f func(*T) error) *TxPoolAddLocalTxCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// AddRebroadcastTxs mocks base method.
func (m *MockTxPool[T, Constraint]) AddRebroadcastTxs(txs []*T) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "AddRebroadcastTxs", txs)
}

// AddRebroadcastTxs indicates an expected call of AddRebroadcastTxs.
func (mr *MockTxPoolMockRecorder[T, Constraint]) AddRebroadcastTxs(txs any) *TxPoolAddRebroadcastTxsCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddRebroadcastTxs", reflect.TypeOf((*MockTxPool[T, Constraint])(nil).AddRebroadcastTxs), txs)
	return &TxPoolAddRebroadcastTxsCall[T, Constraint]{Call: call}
}

// TxPoolAddRebroadcastTxsCall wrap *gomock.Call
type TxPoolAddRebroadcastTxsCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *TxPoolAddRebroadcastTxsCall[T, Constraint]) Return() *TxPoolAddRebroadcastTxsCall[T, Constraint] {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *TxPoolAddRebroadcastTxsCall[T, Constraint]) Do(f func([]*T)) *TxPoolAddRebroadcastTxsCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *TxPoolAddRebroadcastTxsCall[T, Constraint]) DoAndReturn(f func([]*T)) *TxPoolAddRebroadcastTxsCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// AddRemoteTxs mocks base method.
func (m *MockTxPool[T, Constraint]) AddRemoteTxs(txs []*T) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "AddRemoteTxs", txs)
}

// AddRemoteTxs indicates an expected call of AddRemoteTxs.
func (mr *MockTxPoolMockRecorder[T, Constraint]) AddRemoteTxs(txs any) *TxPoolAddRemoteTxsCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddRemoteTxs", reflect.TypeOf((*MockTxPool[T, Constraint])(nil).AddRemoteTxs), txs)
	return &TxPoolAddRemoteTxsCall[T, Constraint]{Call: call}
}

// TxPoolAddRemoteTxsCall wrap *gomock.Call
type TxPoolAddRemoteTxsCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *TxPoolAddRemoteTxsCall[T, Constraint]) Return() *TxPoolAddRemoteTxsCall[T, Constraint] {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *TxPoolAddRemoteTxsCall[T, Constraint]) Do(f func([]*T)) *TxPoolAddRemoteTxsCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *TxPoolAddRemoteTxsCall[T, Constraint]) DoAndReturn(f func([]*T)) *TxPoolAddRemoteTxsCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// FilterOutOfDateRequests mocks base method.
func (m *MockTxPool[T, Constraint]) FilterOutOfDateRequests(timeout bool) []*T {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FilterOutOfDateRequests", timeout)
	ret0, _ := ret[0].([]*T)
	return ret0
}

// FilterOutOfDateRequests indicates an expected call of FilterOutOfDateRequests.
func (mr *MockTxPoolMockRecorder[T, Constraint]) FilterOutOfDateRequests(timeout any) *TxPoolFilterOutOfDateRequestsCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FilterOutOfDateRequests", reflect.TypeOf((*MockTxPool[T, Constraint])(nil).FilterOutOfDateRequests), timeout)
	return &TxPoolFilterOutOfDateRequestsCall[T, Constraint]{Call: call}
}

// TxPoolFilterOutOfDateRequestsCall wrap *gomock.Call
type TxPoolFilterOutOfDateRequestsCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *TxPoolFilterOutOfDateRequestsCall[T, Constraint]) Return(arg0 []*T) *TxPoolFilterOutOfDateRequestsCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *TxPoolFilterOutOfDateRequestsCall[T, Constraint]) Do(f func(bool) []*T) *TxPoolFilterOutOfDateRequestsCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *TxPoolFilterOutOfDateRequestsCall[T, Constraint]) DoAndReturn(f func(bool) []*T) *TxPoolFilterOutOfDateRequestsCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GenerateRequestBatch mocks base method.
func (m *MockTxPool[T, Constraint]) GenerateRequestBatch(typ int) (*txpool.RequestHashBatch[T, Constraint], error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GenerateRequestBatch", typ)
	ret0, _ := ret[0].(*txpool.RequestHashBatch[T, Constraint])
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GenerateRequestBatch indicates an expected call of GenerateRequestBatch.
func (mr *MockTxPoolMockRecorder[T, Constraint]) GenerateRequestBatch(typ any) *TxPoolGenerateRequestBatchCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GenerateRequestBatch", reflect.TypeOf((*MockTxPool[T, Constraint])(nil).GenerateRequestBatch), typ)
	return &TxPoolGenerateRequestBatchCall[T, Constraint]{Call: call}
}

// TxPoolGenerateRequestBatchCall wrap *gomock.Call
type TxPoolGenerateRequestBatchCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *TxPoolGenerateRequestBatchCall[T, Constraint]) Return(arg0 *txpool.RequestHashBatch[T, Constraint], arg1 error) *TxPoolGenerateRequestBatchCall[T, Constraint] {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *TxPoolGenerateRequestBatchCall[T, Constraint]) Do(f func(int) (*txpool.RequestHashBatch[T, Constraint], error)) *TxPoolGenerateRequestBatchCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *TxPoolGenerateRequestBatchCall[T, Constraint]) DoAndReturn(f func(int) (*txpool.RequestHashBatch[T, Constraint], error)) *TxPoolGenerateRequestBatchCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetAccountMeta mocks base method.
func (m *MockTxPool[T, Constraint]) GetAccountMeta(account string, full bool) *txpool.AccountMeta[T, Constraint] {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetAccountMeta", account, full)
	ret0, _ := ret[0].(*txpool.AccountMeta[T, Constraint])
	return ret0
}

// GetAccountMeta indicates an expected call of GetAccountMeta.
func (mr *MockTxPoolMockRecorder[T, Constraint]) GetAccountMeta(account, full any) *TxPoolGetAccountMetaCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAccountMeta", reflect.TypeOf((*MockTxPool[T, Constraint])(nil).GetAccountMeta), account, full)
	return &TxPoolGetAccountMetaCall[T, Constraint]{Call: call}
}

// TxPoolGetAccountMetaCall wrap *gomock.Call
type TxPoolGetAccountMetaCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *TxPoolGetAccountMetaCall[T, Constraint]) Return(arg0 *txpool.AccountMeta[T, Constraint]) *TxPoolGetAccountMetaCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *TxPoolGetAccountMetaCall[T, Constraint]) Do(f func(string, bool) *txpool.AccountMeta[T, Constraint]) *TxPoolGetAccountMetaCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *TxPoolGetAccountMetaCall[T, Constraint]) DoAndReturn(f func(string, bool) *txpool.AccountMeta[T, Constraint]) *TxPoolGetAccountMetaCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetLocalTxs mocks base method.
func (m *MockTxPool[T, Constraint]) GetLocalTxs() [][]byte {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetLocalTxs")
	ret0, _ := ret[0].([][]byte)
	return ret0
}

// GetLocalTxs indicates an expected call of GetLocalTxs.
func (mr *MockTxPoolMockRecorder[T, Constraint]) GetLocalTxs() *TxPoolGetLocalTxsCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetLocalTxs", reflect.TypeOf((*MockTxPool[T, Constraint])(nil).GetLocalTxs))
	return &TxPoolGetLocalTxsCall[T, Constraint]{Call: call}
}

// TxPoolGetLocalTxsCall wrap *gomock.Call
type TxPoolGetLocalTxsCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *TxPoolGetLocalTxsCall[T, Constraint]) Return(arg0 [][]byte) *TxPoolGetLocalTxsCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *TxPoolGetLocalTxsCall[T, Constraint]) Do(f func() [][]byte) *TxPoolGetLocalTxsCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *TxPoolGetLocalTxsCall[T, Constraint]) DoAndReturn(f func() [][]byte) *TxPoolGetLocalTxsCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetMeta mocks base method.
func (m *MockTxPool[T, Constraint]) GetMeta(full bool) *txpool.Meta[T, Constraint] {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetMeta", full)
	ret0, _ := ret[0].(*txpool.Meta[T, Constraint])
	return ret0
}

// GetMeta indicates an expected call of GetMeta.
func (mr *MockTxPoolMockRecorder[T, Constraint]) GetMeta(full any) *TxPoolGetMetaCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMeta", reflect.TypeOf((*MockTxPool[T, Constraint])(nil).GetMeta), full)
	return &TxPoolGetMetaCall[T, Constraint]{Call: call}
}

// TxPoolGetMetaCall wrap *gomock.Call
type TxPoolGetMetaCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *TxPoolGetMetaCall[T, Constraint]) Return(arg0 *txpool.Meta[T, Constraint]) *TxPoolGetMetaCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *TxPoolGetMetaCall[T, Constraint]) Do(f func(bool) *txpool.Meta[T, Constraint]) *TxPoolGetMetaCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *TxPoolGetMetaCall[T, Constraint]) DoAndReturn(f func(bool) *txpool.Meta[T, Constraint]) *TxPoolGetMetaCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetPendingTxByHash mocks base method.
func (m *MockTxPool[T, Constraint]) GetPendingTxByHash(txHash string) *T {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetPendingTxByHash", txHash)
	ret0, _ := ret[0].(*T)
	return ret0
}

// GetPendingTxByHash indicates an expected call of GetPendingTxByHash.
func (mr *MockTxPoolMockRecorder[T, Constraint]) GetPendingTxByHash(txHash any) *TxPoolGetPendingTxByHashCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPendingTxByHash", reflect.TypeOf((*MockTxPool[T, Constraint])(nil).GetPendingTxByHash), txHash)
	return &TxPoolGetPendingTxByHashCall[T, Constraint]{Call: call}
}

// TxPoolGetPendingTxByHashCall wrap *gomock.Call
type TxPoolGetPendingTxByHashCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *TxPoolGetPendingTxByHashCall[T, Constraint]) Return(arg0 *T) *TxPoolGetPendingTxByHashCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *TxPoolGetPendingTxByHashCall[T, Constraint]) Do(f func(string) *T) *TxPoolGetPendingTxByHashCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *TxPoolGetPendingTxByHashCall[T, Constraint]) DoAndReturn(f func(string) *T) *TxPoolGetPendingTxByHashCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetPendingTxCountByAccount mocks base method.
func (m *MockTxPool[T, Constraint]) GetPendingTxCountByAccount(account string) uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetPendingTxCountByAccount", account)
	ret0, _ := ret[0].(uint64)
	return ret0
}

// GetPendingTxCountByAccount indicates an expected call of GetPendingTxCountByAccount.
func (mr *MockTxPoolMockRecorder[T, Constraint]) GetPendingTxCountByAccount(account any) *TxPoolGetPendingTxCountByAccountCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPendingTxCountByAccount", reflect.TypeOf((*MockTxPool[T, Constraint])(nil).GetPendingTxCountByAccount), account)
	return &TxPoolGetPendingTxCountByAccountCall[T, Constraint]{Call: call}
}

// TxPoolGetPendingTxCountByAccountCall wrap *gomock.Call
type TxPoolGetPendingTxCountByAccountCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *TxPoolGetPendingTxCountByAccountCall[T, Constraint]) Return(arg0 uint64) *TxPoolGetPendingTxCountByAccountCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *TxPoolGetPendingTxCountByAccountCall[T, Constraint]) Do(f func(string) uint64) *TxPoolGetPendingTxCountByAccountCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *TxPoolGetPendingTxCountByAccountCall[T, Constraint]) DoAndReturn(f func(string) uint64) *TxPoolGetPendingTxCountByAccountCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetRequestsByHashList mocks base method.
func (m *MockTxPool[T, Constraint]) GetRequestsByHashList(batchHash string, timestamp int64, hashList, deDuplicateTxHashes []string) ([]*T, []bool, map[uint64]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetRequestsByHashList", batchHash, timestamp, hashList, deDuplicateTxHashes)
	ret0, _ := ret[0].([]*T)
	ret1, _ := ret[1].([]bool)
	ret2, _ := ret[2].(map[uint64]string)
	ret3, _ := ret[3].(error)
	return ret0, ret1, ret2, ret3
}

// GetRequestsByHashList indicates an expected call of GetRequestsByHashList.
func (mr *MockTxPoolMockRecorder[T, Constraint]) GetRequestsByHashList(batchHash, timestamp, hashList, deDuplicateTxHashes any) *TxPoolGetRequestsByHashListCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetRequestsByHashList", reflect.TypeOf((*MockTxPool[T, Constraint])(nil).GetRequestsByHashList), batchHash, timestamp, hashList, deDuplicateTxHashes)
	return &TxPoolGetRequestsByHashListCall[T, Constraint]{Call: call}
}

// TxPoolGetRequestsByHashListCall wrap *gomock.Call
type TxPoolGetRequestsByHashListCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *TxPoolGetRequestsByHashListCall[T, Constraint]) Return(txs []*T, list []bool, missingTxsHash map[uint64]string, err error) *TxPoolGetRequestsByHashListCall[T, Constraint] {
	c.Call = c.Call.Return(txs, list, missingTxsHash, err)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *TxPoolGetRequestsByHashListCall[T, Constraint]) Do(f func(string, int64, []string, []string) ([]*T, []bool, map[uint64]string, error)) *TxPoolGetRequestsByHashListCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *TxPoolGetRequestsByHashListCall[T, Constraint]) DoAndReturn(f func(string, int64, []string, []string) ([]*T, []bool, map[uint64]string, error)) *TxPoolGetRequestsByHashListCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetTotalPendingTxCount mocks base method.
func (m *MockTxPool[T, Constraint]) GetTotalPendingTxCount() uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetTotalPendingTxCount")
	ret0, _ := ret[0].(uint64)
	return ret0
}

// GetTotalPendingTxCount indicates an expected call of GetTotalPendingTxCount.
func (mr *MockTxPoolMockRecorder[T, Constraint]) GetTotalPendingTxCount() *TxPoolGetTotalPendingTxCountCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTotalPendingTxCount", reflect.TypeOf((*MockTxPool[T, Constraint])(nil).GetTotalPendingTxCount))
	return &TxPoolGetTotalPendingTxCountCall[T, Constraint]{Call: call}
}

// TxPoolGetTotalPendingTxCountCall wrap *gomock.Call
type TxPoolGetTotalPendingTxCountCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *TxPoolGetTotalPendingTxCountCall[T, Constraint]) Return(arg0 uint64) *TxPoolGetTotalPendingTxCountCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *TxPoolGetTotalPendingTxCountCall[T, Constraint]) Do(f func() uint64) *TxPoolGetTotalPendingTxCountCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *TxPoolGetTotalPendingTxCountCall[T, Constraint]) DoAndReturn(f func() uint64) *TxPoolGetTotalPendingTxCountCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// HasPendingRequestInPool mocks base method.
func (m *MockTxPool[T, Constraint]) HasPendingRequestInPool() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HasPendingRequestInPool")
	ret0, _ := ret[0].(bool)
	return ret0
}

// HasPendingRequestInPool indicates an expected call of HasPendingRequestInPool.
func (mr *MockTxPoolMockRecorder[T, Constraint]) HasPendingRequestInPool() *TxPoolHasPendingRequestInPoolCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HasPendingRequestInPool", reflect.TypeOf((*MockTxPool[T, Constraint])(nil).HasPendingRequestInPool))
	return &TxPoolHasPendingRequestInPoolCall[T, Constraint]{Call: call}
}

// TxPoolHasPendingRequestInPoolCall wrap *gomock.Call
type TxPoolHasPendingRequestInPoolCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *TxPoolHasPendingRequestInPoolCall[T, Constraint]) Return(arg0 bool) *TxPoolHasPendingRequestInPoolCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *TxPoolHasPendingRequestInPoolCall[T, Constraint]) Do(f func() bool) *TxPoolHasPendingRequestInPoolCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *TxPoolHasPendingRequestInPoolCall[T, Constraint]) DoAndReturn(f func() bool) *TxPoolHasPendingRequestInPoolCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Init mocks base method.
func (m *MockTxPool[T, Constraint]) Init(config txpool.ConsensusConfig) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Init", config)
}

// Init indicates an expected call of Init.
func (mr *MockTxPoolMockRecorder[T, Constraint]) Init(config any) *TxPoolInitCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Init", reflect.TypeOf((*MockTxPool[T, Constraint])(nil).Init), config)
	return &TxPoolInitCall[T, Constraint]{Call: call}
}

// TxPoolInitCall wrap *gomock.Call
type TxPoolInitCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *TxPoolInitCall[T, Constraint]) Return() *TxPoolInitCall[T, Constraint] {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *TxPoolInitCall[T, Constraint]) Do(f func(txpool.ConsensusConfig)) *TxPoolInitCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *TxPoolInitCall[T, Constraint]) DoAndReturn(f func(txpool.ConsensusConfig)) *TxPoolInitCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// IsPoolFull mocks base method.
func (m *MockTxPool[T, Constraint]) IsPoolFull() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsPoolFull")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsPoolFull indicates an expected call of IsPoolFull.
func (mr *MockTxPoolMockRecorder[T, Constraint]) IsPoolFull() *TxPoolIsPoolFullCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsPoolFull", reflect.TypeOf((*MockTxPool[T, Constraint])(nil).IsPoolFull))
	return &TxPoolIsPoolFullCall[T, Constraint]{Call: call}
}

// TxPoolIsPoolFullCall wrap *gomock.Call
type TxPoolIsPoolFullCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *TxPoolIsPoolFullCall[T, Constraint]) Return(arg0 bool) *TxPoolIsPoolFullCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *TxPoolIsPoolFullCall[T, Constraint]) Do(f func() bool) *TxPoolIsPoolFullCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *TxPoolIsPoolFullCall[T, Constraint]) DoAndReturn(f func() bool) *TxPoolIsPoolFullCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// PendingRequestsNumberIsReady mocks base method.
func (m *MockTxPool[T, Constraint]) PendingRequestsNumberIsReady() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PendingRequestsNumberIsReady")
	ret0, _ := ret[0].(bool)
	return ret0
}

// PendingRequestsNumberIsReady indicates an expected call of PendingRequestsNumberIsReady.
func (mr *MockTxPoolMockRecorder[T, Constraint]) PendingRequestsNumberIsReady() *TxPoolPendingRequestsNumberIsReadyCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PendingRequestsNumberIsReady", reflect.TypeOf((*MockTxPool[T, Constraint])(nil).PendingRequestsNumberIsReady))
	return &TxPoolPendingRequestsNumberIsReadyCall[T, Constraint]{Call: call}
}

// TxPoolPendingRequestsNumberIsReadyCall wrap *gomock.Call
type TxPoolPendingRequestsNumberIsReadyCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *TxPoolPendingRequestsNumberIsReadyCall[T, Constraint]) Return(arg0 bool) *TxPoolPendingRequestsNumberIsReadyCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *TxPoolPendingRequestsNumberIsReadyCall[T, Constraint]) Do(f func() bool) *TxPoolPendingRequestsNumberIsReadyCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *TxPoolPendingRequestsNumberIsReadyCall[T, Constraint]) DoAndReturn(f func() bool) *TxPoolPendingRequestsNumberIsReadyCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ReConstructBatchByOrder mocks base method.
func (m *MockTxPool[T, Constraint]) ReConstructBatchByOrder(oldBatch *txpool.RequestHashBatch[T, Constraint]) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReConstructBatchByOrder", oldBatch)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReConstructBatchByOrder indicates an expected call of ReConstructBatchByOrder.
func (mr *MockTxPoolMockRecorder[T, Constraint]) ReConstructBatchByOrder(oldBatch any) *TxPoolReConstructBatchByOrderCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReConstructBatchByOrder", reflect.TypeOf((*MockTxPool[T, Constraint])(nil).ReConstructBatchByOrder), oldBatch)
	return &TxPoolReConstructBatchByOrderCall[T, Constraint]{Call: call}
}

// TxPoolReConstructBatchByOrderCall wrap *gomock.Call
type TxPoolReConstructBatchByOrderCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *TxPoolReConstructBatchByOrderCall[T, Constraint]) Return(deDuplicateTxHashes []string, err error) *TxPoolReConstructBatchByOrderCall[T, Constraint] {
	c.Call = c.Call.Return(deDuplicateTxHashes, err)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *TxPoolReConstructBatchByOrderCall[T, Constraint]) Do(f func(*txpool.RequestHashBatch[T, Constraint]) ([]string, error)) *TxPoolReConstructBatchByOrderCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *TxPoolReConstructBatchByOrderCall[T, Constraint]) DoAndReturn(f func(*txpool.RequestHashBatch[T, Constraint]) ([]string, error)) *TxPoolReConstructBatchByOrderCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// ReceiveMissingRequests mocks base method.
func (m *MockTxPool[T, Constraint]) ReceiveMissingRequests(batchHash string, txs map[uint64]*T) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReceiveMissingRequests", batchHash, txs)
	ret0, _ := ret[0].(error)
	return ret0
}

// ReceiveMissingRequests indicates an expected call of ReceiveMissingRequests.
func (mr *MockTxPoolMockRecorder[T, Constraint]) ReceiveMissingRequests(batchHash, txs any) *TxPoolReceiveMissingRequestsCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReceiveMissingRequests", reflect.TypeOf((*MockTxPool[T, Constraint])(nil).ReceiveMissingRequests), batchHash, txs)
	return &TxPoolReceiveMissingRequestsCall[T, Constraint]{Call: call}
}

// TxPoolReceiveMissingRequestsCall wrap *gomock.Call
type TxPoolReceiveMissingRequestsCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *TxPoolReceiveMissingRequestsCall[T, Constraint]) Return(arg0 error) *TxPoolReceiveMissingRequestsCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *TxPoolReceiveMissingRequestsCall[T, Constraint]) Do(f func(string, map[uint64]*T) error) *TxPoolReceiveMissingRequestsCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *TxPoolReceiveMissingRequestsCall[T, Constraint]) DoAndReturn(f func(string, map[uint64]*T) error) *TxPoolReceiveMissingRequestsCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RemoveBatches mocks base method.
func (m *MockTxPool[T, Constraint]) RemoveBatches(batchHashList []string) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "RemoveBatches", batchHashList)
}

// RemoveBatches indicates an expected call of RemoveBatches.
func (mr *MockTxPoolMockRecorder[T, Constraint]) RemoveBatches(batchHashList any) *TxPoolRemoveBatchesCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveBatches", reflect.TypeOf((*MockTxPool[T, Constraint])(nil).RemoveBatches), batchHashList)
	return &TxPoolRemoveBatchesCall[T, Constraint]{Call: call}
}

// TxPoolRemoveBatchesCall wrap *gomock.Call
type TxPoolRemoveBatchesCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *TxPoolRemoveBatchesCall[T, Constraint]) Return() *TxPoolRemoveBatchesCall[T, Constraint] {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *TxPoolRemoveBatchesCall[T, Constraint]) Do(f func([]string)) *TxPoolRemoveBatchesCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *TxPoolRemoveBatchesCall[T, Constraint]) DoAndReturn(f func([]string)) *TxPoolRemoveBatchesCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RemoveStateUpdatingTxs mocks base method.
func (m *MockTxPool[T, Constraint]) RemoveStateUpdatingTxs(txPointerList []*txpool.WrapperTxPointer) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "RemoveStateUpdatingTxs", txPointerList)
}

// RemoveStateUpdatingTxs indicates an expected call of RemoveStateUpdatingTxs.
func (mr *MockTxPoolMockRecorder[T, Constraint]) RemoveStateUpdatingTxs(txPointerList any) *TxPoolRemoveStateUpdatingTxsCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveStateUpdatingTxs", reflect.TypeOf((*MockTxPool[T, Constraint])(nil).RemoveStateUpdatingTxs), txPointerList)
	return &TxPoolRemoveStateUpdatingTxsCall[T, Constraint]{Call: call}
}

// TxPoolRemoveStateUpdatingTxsCall wrap *gomock.Call
type TxPoolRemoveStateUpdatingTxsCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *TxPoolRemoveStateUpdatingTxsCall[T, Constraint]) Return() *TxPoolRemoveStateUpdatingTxsCall[T, Constraint] {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *TxPoolRemoveStateUpdatingTxsCall[T, Constraint]) Do(f func([]*txpool.WrapperTxPointer)) *TxPoolRemoveStateUpdatingTxsCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *TxPoolRemoveStateUpdatingTxsCall[T, Constraint]) DoAndReturn(f func([]*txpool.WrapperTxPointer)) *TxPoolRemoveStateUpdatingTxsCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RestoreOneBatch mocks base method.
func (m *MockTxPool[T, Constraint]) RestoreOneBatch(hash string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RestoreOneBatch", hash)
	ret0, _ := ret[0].(error)
	return ret0
}

// RestoreOneBatch indicates an expected call of RestoreOneBatch.
func (mr *MockTxPoolMockRecorder[T, Constraint]) RestoreOneBatch(hash any) *TxPoolRestoreOneBatchCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RestoreOneBatch", reflect.TypeOf((*MockTxPool[T, Constraint])(nil).RestoreOneBatch), hash)
	return &TxPoolRestoreOneBatchCall[T, Constraint]{Call: call}
}

// TxPoolRestoreOneBatchCall wrap *gomock.Call
type TxPoolRestoreOneBatchCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *TxPoolRestoreOneBatchCall[T, Constraint]) Return(arg0 error) *TxPoolRestoreOneBatchCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *TxPoolRestoreOneBatchCall[T, Constraint]) Do(f func(string) error) *TxPoolRestoreOneBatchCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *TxPoolRestoreOneBatchCall[T, Constraint]) DoAndReturn(f func(string) error) *TxPoolRestoreOneBatchCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// RestorePool mocks base method.
func (m *MockTxPool[T, Constraint]) RestorePool() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "RestorePool")
}

// RestorePool indicates an expected call of RestorePool.
func (mr *MockTxPoolMockRecorder[T, Constraint]) RestorePool() *TxPoolRestorePoolCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RestorePool", reflect.TypeOf((*MockTxPool[T, Constraint])(nil).RestorePool))
	return &TxPoolRestorePoolCall[T, Constraint]{Call: call}
}

// TxPoolRestorePoolCall wrap *gomock.Call
type TxPoolRestorePoolCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *TxPoolRestorePoolCall[T, Constraint]) Return() *TxPoolRestorePoolCall[T, Constraint] {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *TxPoolRestorePoolCall[T, Constraint]) Do(f func()) *TxPoolRestorePoolCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *TxPoolRestorePoolCall[T, Constraint]) DoAndReturn(f func()) *TxPoolRestorePoolCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// SendMissingRequests mocks base method.
func (m *MockTxPool[T, Constraint]) SendMissingRequests(batchHash string, missingHashList map[uint64]string) (map[uint64]*T, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SendMissingRequests", batchHash, missingHashList)
	ret0, _ := ret[0].(map[uint64]*T)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// SendMissingRequests indicates an expected call of SendMissingRequests.
func (mr *MockTxPoolMockRecorder[T, Constraint]) SendMissingRequests(batchHash, missingHashList any) *TxPoolSendMissingRequestsCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SendMissingRequests", reflect.TypeOf((*MockTxPool[T, Constraint])(nil).SendMissingRequests), batchHash, missingHashList)
	return &TxPoolSendMissingRequestsCall[T, Constraint]{Call: call}
}

// TxPoolSendMissingRequestsCall wrap *gomock.Call
type TxPoolSendMissingRequestsCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *TxPoolSendMissingRequestsCall[T, Constraint]) Return(txs map[uint64]*T, err error) *TxPoolSendMissingRequestsCall[T, Constraint] {
	c.Call = c.Call.Return(txs, err)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *TxPoolSendMissingRequestsCall[T, Constraint]) Do(f func(string, map[uint64]string) (map[uint64]*T, error)) *TxPoolSendMissingRequestsCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *TxPoolSendMissingRequestsCall[T, Constraint]) DoAndReturn(f func(string, map[uint64]string) (map[uint64]*T, error)) *TxPoolSendMissingRequestsCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Start mocks base method.
func (m *MockTxPool[T, Constraint]) Start() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Start")
	ret0, _ := ret[0].(error)
	return ret0
}

// Start indicates an expected call of Start.
func (mr *MockTxPoolMockRecorder[T, Constraint]) Start() *TxPoolStartCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Start", reflect.TypeOf((*MockTxPool[T, Constraint])(nil).Start))
	return &TxPoolStartCall[T, Constraint]{Call: call}
}

// TxPoolStartCall wrap *gomock.Call
type TxPoolStartCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *TxPoolStartCall[T, Constraint]) Return(arg0 error) *TxPoolStartCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *TxPoolStartCall[T, Constraint]) Do(f func() error) *TxPoolStartCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *TxPoolStartCall[T, Constraint]) DoAndReturn(f func() error) *TxPoolStartCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Stop mocks base method.
func (m *MockTxPool[T, Constraint]) Stop() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Stop")
}

// Stop indicates an expected call of Stop.
func (mr *MockTxPoolMockRecorder[T, Constraint]) Stop() *TxPoolStopCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Stop", reflect.TypeOf((*MockTxPool[T, Constraint])(nil).Stop))
	return &TxPoolStopCall[T, Constraint]{Call: call}
}

// TxPoolStopCall wrap *gomock.Call
type TxPoolStopCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *TxPoolStopCall[T, Constraint]) Return() *TxPoolStopCall[T, Constraint] {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *TxPoolStopCall[T, Constraint]) Do(f func()) *TxPoolStopCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *TxPoolStopCall[T, Constraint]) DoAndReturn(f func()) *TxPoolStopCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UpdateChainInfo mocks base method.
func (m *MockTxPool[T, Constraint]) UpdateChainInfo(info *txpool.ChainInfo) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "UpdateChainInfo", info)
}

// UpdateChainInfo indicates an expected call of UpdateChainInfo.
func (mr *MockTxPoolMockRecorder[T, Constraint]) UpdateChainInfo(info any) *TxPoolUpdateChainInfoCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateChainInfo", reflect.TypeOf((*MockTxPool[T, Constraint])(nil).UpdateChainInfo), info)
	return &TxPoolUpdateChainInfoCall[T, Constraint]{Call: call}
}

// TxPoolUpdateChainInfoCall wrap *gomock.Call
type TxPoolUpdateChainInfoCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *TxPoolUpdateChainInfoCall[T, Constraint]) Return() *TxPoolUpdateChainInfoCall[T, Constraint] {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *TxPoolUpdateChainInfoCall[T, Constraint]) Do(f func(*txpool.ChainInfo)) *TxPoolUpdateChainInfoCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *TxPoolUpdateChainInfoCall[T, Constraint]) DoAndReturn(f func(*txpool.ChainInfo)) *TxPoolUpdateChainInfoCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MocktxPoolInfo is a mock of txPoolInfo interface.
type MocktxPoolInfo[T any, Constraint types.TXConstraint[T]] struct {
	ctrl     *gomock.Controller
	recorder *MocktxPoolInfoMockRecorder[T, Constraint]
}

// MocktxPoolInfoMockRecorder is the mock recorder for MocktxPoolInfo.
type MocktxPoolInfoMockRecorder[T any, Constraint types.TXConstraint[T]] struct {
	mock *MocktxPoolInfo[T, Constraint]
}

// NewMocktxPoolInfo creates a new mock instance.
func NewMocktxPoolInfo[T any, Constraint types.TXConstraint[T]](ctrl *gomock.Controller) *MocktxPoolInfo[T, Constraint] {
	mock := &MocktxPoolInfo[T, Constraint]{ctrl: ctrl}
	mock.recorder = &MocktxPoolInfoMockRecorder[T, Constraint]{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MocktxPoolInfo[T, Constraint]) EXPECT() *MocktxPoolInfoMockRecorder[T, Constraint] {
	return m.recorder
}

// GetAccountMeta mocks base method.
func (m *MocktxPoolInfo[T, Constraint]) GetAccountMeta(account string, full bool) *txpool.AccountMeta[T, Constraint] {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetAccountMeta", account, full)
	ret0, _ := ret[0].(*txpool.AccountMeta[T, Constraint])
	return ret0
}

// GetAccountMeta indicates an expected call of GetAccountMeta.
func (mr *MocktxPoolInfoMockRecorder[T, Constraint]) GetAccountMeta(account, full any) *txPoolInfoGetAccountMetaCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetAccountMeta", reflect.TypeOf((*MocktxPoolInfo[T, Constraint])(nil).GetAccountMeta), account, full)
	return &txPoolInfoGetAccountMetaCall[T, Constraint]{Call: call}
}

// txPoolInfoGetAccountMetaCall wrap *gomock.Call
type txPoolInfoGetAccountMetaCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *txPoolInfoGetAccountMetaCall[T, Constraint]) Return(arg0 *txpool.AccountMeta[T, Constraint]) *txPoolInfoGetAccountMetaCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *txPoolInfoGetAccountMetaCall[T, Constraint]) Do(f func(string, bool) *txpool.AccountMeta[T, Constraint]) *txPoolInfoGetAccountMetaCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *txPoolInfoGetAccountMetaCall[T, Constraint]) DoAndReturn(f func(string, bool) *txpool.AccountMeta[T, Constraint]) *txPoolInfoGetAccountMetaCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetMeta mocks base method.
func (m *MocktxPoolInfo[T, Constraint]) GetMeta(full bool) *txpool.Meta[T, Constraint] {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetMeta", full)
	ret0, _ := ret[0].(*txpool.Meta[T, Constraint])
	return ret0
}

// GetMeta indicates an expected call of GetMeta.
func (mr *MocktxPoolInfoMockRecorder[T, Constraint]) GetMeta(full any) *txPoolInfoGetMetaCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetMeta", reflect.TypeOf((*MocktxPoolInfo[T, Constraint])(nil).GetMeta), full)
	return &txPoolInfoGetMetaCall[T, Constraint]{Call: call}
}

// txPoolInfoGetMetaCall wrap *gomock.Call
type txPoolInfoGetMetaCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *txPoolInfoGetMetaCall[T, Constraint]) Return(arg0 *txpool.Meta[T, Constraint]) *txPoolInfoGetMetaCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *txPoolInfoGetMetaCall[T, Constraint]) Do(f func(bool) *txpool.Meta[T, Constraint]) *txPoolInfoGetMetaCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *txPoolInfoGetMetaCall[T, Constraint]) DoAndReturn(f func(bool) *txpool.Meta[T, Constraint]) *txPoolInfoGetMetaCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetPendingTxByHash mocks base method.
func (m *MocktxPoolInfo[T, Constraint]) GetPendingTxByHash(txHash string) *T {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetPendingTxByHash", txHash)
	ret0, _ := ret[0].(*T)
	return ret0
}

// GetPendingTxByHash indicates an expected call of GetPendingTxByHash.
func (mr *MocktxPoolInfoMockRecorder[T, Constraint]) GetPendingTxByHash(txHash any) *txPoolInfoGetPendingTxByHashCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPendingTxByHash", reflect.TypeOf((*MocktxPoolInfo[T, Constraint])(nil).GetPendingTxByHash), txHash)
	return &txPoolInfoGetPendingTxByHashCall[T, Constraint]{Call: call}
}

// txPoolInfoGetPendingTxByHashCall wrap *gomock.Call
type txPoolInfoGetPendingTxByHashCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *txPoolInfoGetPendingTxByHashCall[T, Constraint]) Return(arg0 *T) *txPoolInfoGetPendingTxByHashCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *txPoolInfoGetPendingTxByHashCall[T, Constraint]) Do(f func(string) *T) *txPoolInfoGetPendingTxByHashCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *txPoolInfoGetPendingTxByHashCall[T, Constraint]) DoAndReturn(f func(string) *T) *txPoolInfoGetPendingTxByHashCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetPendingTxCountByAccount mocks base method.
func (m *MocktxPoolInfo[T, Constraint]) GetPendingTxCountByAccount(account string) uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetPendingTxCountByAccount", account)
	ret0, _ := ret[0].(uint64)
	return ret0
}

// GetPendingTxCountByAccount indicates an expected call of GetPendingTxCountByAccount.
func (mr *MocktxPoolInfoMockRecorder[T, Constraint]) GetPendingTxCountByAccount(account any) *txPoolInfoGetPendingTxCountByAccountCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPendingTxCountByAccount", reflect.TypeOf((*MocktxPoolInfo[T, Constraint])(nil).GetPendingTxCountByAccount), account)
	return &txPoolInfoGetPendingTxCountByAccountCall[T, Constraint]{Call: call}
}

// txPoolInfoGetPendingTxCountByAccountCall wrap *gomock.Call
type txPoolInfoGetPendingTxCountByAccountCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *txPoolInfoGetPendingTxCountByAccountCall[T, Constraint]) Return(arg0 uint64) *txPoolInfoGetPendingTxCountByAccountCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *txPoolInfoGetPendingTxCountByAccountCall[T, Constraint]) Do(f func(string) uint64) *txPoolInfoGetPendingTxCountByAccountCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *txPoolInfoGetPendingTxCountByAccountCall[T, Constraint]) DoAndReturn(f func(string) uint64) *txPoolInfoGetPendingTxCountByAccountCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetTotalPendingTxCount mocks base method.
func (m *MocktxPoolInfo[T, Constraint]) GetTotalPendingTxCount() uint64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetTotalPendingTxCount")
	ret0, _ := ret[0].(uint64)
	return ret0
}

// GetTotalPendingTxCount indicates an expected call of GetTotalPendingTxCount.
func (mr *MocktxPoolInfoMockRecorder[T, Constraint]) GetTotalPendingTxCount() *txPoolInfoGetTotalPendingTxCountCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetTotalPendingTxCount", reflect.TypeOf((*MocktxPoolInfo[T, Constraint])(nil).GetTotalPendingTxCount))
	return &txPoolInfoGetTotalPendingTxCountCall[T, Constraint]{Call: call}
}

// txPoolInfoGetTotalPendingTxCountCall wrap *gomock.Call
type txPoolInfoGetTotalPendingTxCountCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *txPoolInfoGetTotalPendingTxCountCall[T, Constraint]) Return(arg0 uint64) *txPoolInfoGetTotalPendingTxCountCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *txPoolInfoGetTotalPendingTxCountCall[T, Constraint]) Do(f func() uint64) *txPoolInfoGetTotalPendingTxCountCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *txPoolInfoGetTotalPendingTxCountCall[T, Constraint]) DoAndReturn(f func() uint64) *txPoolInfoGetTotalPendingTxCountCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// HasPendingRequestInPool mocks base method.
func (m *MocktxPoolInfo[T, Constraint]) HasPendingRequestInPool() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HasPendingRequestInPool")
	ret0, _ := ret[0].(bool)
	return ret0
}

// HasPendingRequestInPool indicates an expected call of HasPendingRequestInPool.
func (mr *MocktxPoolInfoMockRecorder[T, Constraint]) HasPendingRequestInPool() *txPoolInfoHasPendingRequestInPoolCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HasPendingRequestInPool", reflect.TypeOf((*MocktxPoolInfo[T, Constraint])(nil).HasPendingRequestInPool))
	return &txPoolInfoHasPendingRequestInPoolCall[T, Constraint]{Call: call}
}

// txPoolInfoHasPendingRequestInPoolCall wrap *gomock.Call
type txPoolInfoHasPendingRequestInPoolCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *txPoolInfoHasPendingRequestInPoolCall[T, Constraint]) Return(arg0 bool) *txPoolInfoHasPendingRequestInPoolCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *txPoolInfoHasPendingRequestInPoolCall[T, Constraint]) Do(f func() bool) *txPoolInfoHasPendingRequestInPoolCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *txPoolInfoHasPendingRequestInPoolCall[T, Constraint]) DoAndReturn(f func() bool) *txPoolInfoHasPendingRequestInPoolCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// IsPoolFull mocks base method.
func (m *MocktxPoolInfo[T, Constraint]) IsPoolFull() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsPoolFull")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsPoolFull indicates an expected call of IsPoolFull.
func (mr *MocktxPoolInfoMockRecorder[T, Constraint]) IsPoolFull() *txPoolInfoIsPoolFullCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsPoolFull", reflect.TypeOf((*MocktxPoolInfo[T, Constraint])(nil).IsPoolFull))
	return &txPoolInfoIsPoolFullCall[T, Constraint]{Call: call}
}

// txPoolInfoIsPoolFullCall wrap *gomock.Call
type txPoolInfoIsPoolFullCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *txPoolInfoIsPoolFullCall[T, Constraint]) Return(arg0 bool) *txPoolInfoIsPoolFullCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *txPoolInfoIsPoolFullCall[T, Constraint]) Do(f func() bool) *txPoolInfoIsPoolFullCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *txPoolInfoIsPoolFullCall[T, Constraint]) DoAndReturn(f func() bool) *txPoolInfoIsPoolFullCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// PendingRequestsNumberIsReady mocks base method.
func (m *MocktxPoolInfo[T, Constraint]) PendingRequestsNumberIsReady() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PendingRequestsNumberIsReady")
	ret0, _ := ret[0].(bool)
	return ret0
}

// PendingRequestsNumberIsReady indicates an expected call of PendingRequestsNumberIsReady.
func (mr *MocktxPoolInfoMockRecorder[T, Constraint]) PendingRequestsNumberIsReady() *txPoolInfoPendingRequestsNumberIsReadyCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PendingRequestsNumberIsReady", reflect.TypeOf((*MocktxPoolInfo[T, Constraint])(nil).PendingRequestsNumberIsReady))
	return &txPoolInfoPendingRequestsNumberIsReadyCall[T, Constraint]{Call: call}
}

// txPoolInfoPendingRequestsNumberIsReadyCall wrap *gomock.Call
type txPoolInfoPendingRequestsNumberIsReadyCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *txPoolInfoPendingRequestsNumberIsReadyCall[T, Constraint]) Return(arg0 bool) *txPoolInfoPendingRequestsNumberIsReadyCall[T, Constraint] {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *txPoolInfoPendingRequestsNumberIsReadyCall[T, Constraint]) Do(f func() bool) *txPoolInfoPendingRequestsNumberIsReadyCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *txPoolInfoPendingRequestsNumberIsReadyCall[T, Constraint]) DoAndReturn(f func() bool) *txPoolInfoPendingRequestsNumberIsReadyCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// UpdateChainInfo mocks base method.
func (m *MocktxPoolInfo[T, Constraint]) UpdateChainInfo(info *txpool.ChainInfo) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "UpdateChainInfo", info)
}

// UpdateChainInfo indicates an expected call of UpdateChainInfo.
func (mr *MocktxPoolInfoMockRecorder[T, Constraint]) UpdateChainInfo(info any) *txPoolInfoUpdateChainInfoCall[T, Constraint] {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateChainInfo", reflect.TypeOf((*MocktxPoolInfo[T, Constraint])(nil).UpdateChainInfo), info)
	return &txPoolInfoUpdateChainInfoCall[T, Constraint]{Call: call}
}

// txPoolInfoUpdateChainInfoCall wrap *gomock.Call
type txPoolInfoUpdateChainInfoCall[T any, Constraint types.TXConstraint[T]] struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *txPoolInfoUpdateChainInfoCall[T, Constraint]) Return() *txPoolInfoUpdateChainInfoCall[T, Constraint] {
	c.Call = c.Call.Return()
	return c
}

// Do rewrite *gomock.Call.Do
func (c *txPoolInfoUpdateChainInfoCall[T, Constraint]) Do(f func(*txpool.ChainInfo)) *txPoolInfoUpdateChainInfoCall[T, Constraint] {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *txPoolInfoUpdateChainInfoCall[T, Constraint]) DoAndReturn(f func(*txpool.ChainInfo)) *txPoolInfoUpdateChainInfoCall[T, Constraint] {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
